Features I want to have:
- Opening and closing, saving
- Multi-level undo and redo
- Tabs
- Command pallette
- Status bar
- Refactor mode
- Built-in console
- Multi-step keybindings
- Incremental, multi-file find and replace
- File explorer (tree view?)
- Repeated commands
- Jump mode
- Line wrapping, split on word
- Collapsing
- Autocomplete
- Themes
- Auto-indent
- Highlighting brackets
- Jump to brackets
- Jump/display start of block?
- Built-in debugger?
- Split view?
- Python interpreter?
- Scroll wheel support?
- Scroll past end of file
- Bookmarks / jump points
- Semantic find / replace patterns, ex:
	Find pattern is parsed as an expression/statement.
	"_" is a wildcard.
	var x => var y replaces definition and all uses in scope.
	"func f" only matches outside of strings or comments.
	editor can read changes to an external library and refactor your code based on the changes
	ex. library.f() renamed to library.g() refactor?
	maybe each version of a library can have a semantic "diff" that gets autogenerated.
	this could allow automatic updating for users.


Design questions:
- List of lines vs. rope vs. piece table vs. gap buffer?
- Scripting vs. no scripting?
- Config files?
- How to buffer large files?
- Modal vs. modeless?
- Memory allocation strategy?
- How to store config data? Struct vs. dictionary?


Editor design:
- Reads file into a doubly linked list of strings representing each line.
- Each line has some extra space at the end of it to expand into.
- Simplest possible implementation until it causes performance issues.
- Config data is stored in a plain struct and parsed from a config file.


Structs:
- Line: Stores a single line of text.
- Buffer: Stores the lines of the file.
- Editor: Stores the state of the editor. E.g., open buffers, cursor position, mode.
- Config: Stores configuration data for the editor.
- Theme: Stores a theme.

